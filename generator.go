package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
)

type options struct {
	getter bool
	setter bool
}

type optionsFn func(*options)

func WithGetter(v bool) optionsFn {
	return func(o *options) {
		o.getter = v
	}
}

func WithSetter(v bool) optionsFn {
	return func(o *options) {
		o.setter = v
	}
}

type Generator struct {
	Name string
	Dir  string
	Pkg  string
	Type string
}

func (g *Generator) Generate(optsFn ...optionsFn) error {
	opts := &options{}
	for _, o := range optsFn {
		o(opts)
	}

	f, err := os.Create(g.FilePath())
	if err != nil {
		return err
	}
	defer f.Close()

	g.Printlnf(f, "// Code generated by `%s`. DO NOT EDIT.", strings.Join(os.Args, " "))
	g.Printlnf(f, "")
	g.Printlnf(f, "package %s", g.Pkg)

	if opts.getter {
		g.Printlnf(f, "")
		g.Printlnf(f, "func Get%s() %s {", g.CamelCaseName(), g.Type)
		g.Printlnf(f, "        return %s", g.Name)
		g.Printlnf(f, "}")
	}

	if opts.setter {
		g.Printlnf(f, "")
		g.Printlnf(f, "func Set%s(%s %s) {", g.CamelCaseName(), g.newValueName(), g.Type)
		g.Printlnf(f, "        %s = %s", g.Name, g.newValueName())
		g.Printlnf(f, "}")
	}

	return nil
}

func (g *Generator) FilePath() string {
	return filepath.Join(g.Dir, strings.ToLower(g.Name)+"_goaccessor.go")
}

func (g *Generator) CamelCaseName() string {
	return strings.ToUpper(g.Name[0:1]) + g.Name[1:]
}

func (g *Generator) newValueName() string {
	if g.Name != "v" {
		return "v"
	}
	return "value"
}

func (g *Generator) Printlnf(f *os.File, format string, a ...interface{}) {
	_, err := fmt.Fprintf(f, format+"\n", a...)
	if err != nil {
		log.Fatalf("Failed to Fprintf: %s", err.Error())
	}
}
