package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

type options struct {
	getter   bool
	setter   bool
	prefix   string
	includes map[string]struct{}
	excludes map[string]struct{}
}

type optionsFn func(*options)

func WithGetter(v bool) optionsFn {
	return func(o *options) {
		o.getter = v
	}
}

func WithSetter(v bool) optionsFn {
	return func(o *options) {
		o.setter = v
	}
}

func WithPrefix(p string) optionsFn {
	return func(o *options) {
		o.prefix = p
	}
}

func WithIncludes(includes []string) optionsFn {
	return func(o *options) {
		if len(includes) == 0 {
			o.includes = nil
			return
		}

		o.includes = make(map[string]struct{}, len(includes))
		for _, include := range includes {
			o.includes[include] = struct{}{}
		}
	}
}

func WithExcludes(excludes []string) optionsFn {
	return func(o *options) {
		if len(excludes) == 0 {
			o.excludes = nil
			return
		}

		o.excludes = make(map[string]struct{}, len(excludes))
		for _, exclude := range excludes {
			o.excludes[exclude] = struct{}{}
		}
	}
}

type GeneratorType int

const (
	GeneratorTypeVariable GeneratorType = iota
	GeneratorTypeStructure
)

type Generator struct {
	Name          string
	Dir           string
	Pkg           string
	Type          string
	TypeParams    []string
	ReceiverName  string
	Fields        map[string]string
	Methods       map[string]struct{}
	GeneratorType GeneratorType

	opts *options
}

func (g *Generator) Generate(optsFn ...optionsFn) error {
	g.opts = &options{}
	for _, o := range optsFn {
		o(g.opts)
	}

	var err error
	switch g.GeneratorType {
	case GeneratorTypeVariable:
		err = g.WriteVarAccessor()
	case GeneratorTypeStructure:
		err = g.WriteStructAccessor()
	default:
		err = fmt.Errorf("unknown generator type")
	}
	if err != nil {
		return err
	}

	return nil
}

func (g *Generator) WriteVarAccessor() error {
	cl := append(g.getPackageCodeLines(), g.getVarAccessorCodeLines()...)
	return g.writeFile(cl)
}

func (g *Generator) WriteStructAccessor() error {
	cl := append(g.getPackageCodeLines(), g.getStructCodeLines()...)
	return g.writeFile(cl)
}

type codeLines []struct {
	format string
	a      []interface{}
}

func (c codeLines) Append(format string, a ...interface{}) codeLines {
	return append(c, struct {
		format string
		a      []interface{}
	}{format, a})
}

func (g *Generator) getPackageCodeLines() (cl codeLines) {
	cl = cl.Append("// Code generated by `%s`. DO NOT EDIT.", strings.Join(os.Args, " "))
	cl = cl.Append("")
	cl = cl.Append("package %s", g.Pkg)
	return
}

func (g *Generator) getVarAccessorCodeLines() (cl codeLines) {
	if g.opts.getter {
		cl = cl.Append("")
		cl = cl.Append("func %s() %s {", concat("get", g.opts.prefix, g.Name), g.Type)
		cl = cl.Append("        return %s", g.Name)
		cl = cl.Append("}")
	}

	if g.opts.setter {
		cl = cl.Append("")
		cl = cl.Append("func %s(%s %s) {", concat("set", g.opts.prefix, g.Name), g.newValueName(), g.Type)
		cl = cl.Append("        %s = %s", g.Name, g.newValueName())
		cl = cl.Append("}")
	}
	return
}

func (g *Generator) getStructCodeLines() (cl codeLines) {
	for fieldName, fieldType := range g.Fields {
		if includes := g.opts.includes; len(includes) > 0 {
			if _, ok := includes[fieldName]; !ok {
				continue
			}
		}

		if excludes := g.opts.excludes; len(excludes) > 0 {
			if _, ok := excludes[fieldName]; ok {
				continue
			}
		}

		getMethodName := concat("get", g.opts.prefix, fieldName)
		if _, ok := g.Methods[getMethodName]; g.opts.getter && !ok {
			cl = cl.Append("")
			cl = cl.Append("func (%s *%s) %s() %s {", g.getReceiverName(), g.getReceiverType(), getMethodName, fieldType)
			cl = cl.Append("        return %s.%s", g.getReceiverName(), fieldName)
			cl = cl.Append("}")
		}

		setMethodName := concat("set", g.opts.prefix, fieldName)
		if _, ok := g.Methods[setMethodName]; g.opts.setter && !ok {
			cl = cl.Append("")
			cl = cl.Append("func (%s *%s) %s(%s %s) {", g.getReceiverName(), g.getReceiverType(), setMethodName, g.newValueName(), fieldType)
			cl = cl.Append("        %s.%s = %s", g.getReceiverName(), fieldName, g.newValueName())
			cl = cl.Append("}")
		}
	}
	return
}

func (g *Generator) getReceiverName() string {
	if g.ReceiverName != "" {
		return g.ReceiverName
	}
	g.ReceiverName = strings.ToLower(g.Type[:1])
	return g.ReceiverName
}

func (g *Generator) newValueName() string {
	if g.Name != "v" && g.getReceiverName() != "v" {
		return "v"
	}
	return "val"
}

func (g *Generator) getReceiverType() string {
	if len(g.TypeParams) == 0 {
		return g.Name
	}
	return g.Name + "[" + strings.Join(g.TypeParams, ", ") + "]"
}

func (g *Generator) writeFile(cl codeLines) error {
	f, err := os.Create(g.FilePath())
	if err != nil {
		return fmt.Errorf("os.Create(%s): %w", g.FilePath(), err)
	}
	defer f.Close()

	for _, line := range cl {
		_, err := fmt.Fprintf(f, line.format+"\n", line.a...)
		if err != nil {
			return fmt.Errorf("fmt.Fprintf(%s, %v): %w", line.format, line.a, err)
		}
	}
	return nil
}

func (g *Generator) FilePath() string {
	return filepath.Join(g.Dir, strings.ToLower(g.Name)+"_goaccessor.go")
}

// helper functions

func concat(strs ...string) (s string) {
	for _, str := range strs {
		if str == "" {
			continue
		}
		s += upper(str)
	}
	return
}

func upper(str string) string {
	return strings.ToUpper(str[:1]) + str[1:]
}
